// Package dlog exports logging primitives that log to stderr
package dlog

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	Lmsgprefix                    // move the "prefix" from the beginning of the line to before the message
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

// Different levels of logging.
const (
	DebugLevel int = iota
	InfoLevel
)

type globalState struct {
	currentLevel int
	logger       interface {
		log(context.Context, int, any)
	}
}

var (
	mu    sync.RWMutex
	state = globalState{
		currentLevel: DebugLevel,
		logger:       stdLogger{},
	}
)

type (
	// traceIDKey is the type of the context key for trace IDs.
	traceIDKey struct{}

	// labelsKey is the type of the context key for labels.
	labelsKey struct{}
)

// NewContextWithTraceID creates a new context from ctx that adds the trace ID.
func NewContextWithTraceID(ctx context.Context, traceID string) context.Context {
	return context.WithValue(ctx, traceIDKey{}, traceID)
}

// NewContextWithLabel creates anew context from ctx that adds a label that will
// appear in the log entry.
func NewContextWithLabel(ctx context.Context, key, value string) context.Context {
	oldLabels, _ := ctx.Value(labelsKey{}).(map[string]string)
	// Copy the labels, to preserve immutability of contexts.
	newLabels := map[string]string{}
	for k, v := range oldLabels {
		newLabels[k] = v
	}
	newLabels[key] = value
	return context.WithValue(ctx, labelsKey{}, newLabels)
}

func globals() globalState {
	mu.RLock()
	defer mu.RUnlock()
	return state
}

type stdLogger struct{}

func (stdLogger) log(ctx context.Context, level int, payload any) {
	var extras []string
	traceID, _ := ctx.Value(traceIDKey{}).(string)
	if traceID != "" {
		extras = append(extras, fmt.Sprintf("traceID %s", traceID))
	}
	if labels, ok := ctx.Value(labelsKey{}).(map[string]string); ok {
		extras = append(extras, fmt.Sprint(labels))
	}
	var extra string
	if len(extras) > 0 {
		extra = " (" + strings.Join(extras, ", ") + ")"
	}
	log.Printf("%s%s: %+v", toString(level), extra, payload)
}

func toString(level int) string {
	switch level {
	case InfoLevel:
		return "info"
	case DebugLevel:
		return "debug"
	}
	return "unknown"
}

// toLevel returns the log level from a given string.
// Possible input values are "debug", "info".
func toLevel(v string) int {
	switch v {
	case "info":
		return InfoLevel
	case "debug":
		return DebugLevel

	}
	// Default log level in case of invalid input.
	Debugf(context.Background(), "Error: %s is invalid LogLevel. Possible values are [debug, info]", v)
	return DebugLevel
}

// GetLevel returns the current logging level.
func GetLevel() string {
	return toString(getLevel())
}

// getLevel returns the current logging level.
func getLevel() int {
	g := globals()

	return g.currentLevel
}

// SetFlags sets the output flags for the logger.
// The flag bits are Ldate, Ltime, and so on.
func SetFlags(flag int) {
	log.SetFlags(flag)
}

// SetLevel sets the current level of logging.
// Possible input values are "debug", "info".
func SetLevel(level string) error {
	l := toLevel(level)
	mu.Lock()
	state.currentLevel = l
	mu.Unlock()
	return nil
}

// Infof logs a formatted string at the Info level.
func Debugf(ctx context.Context, format string, args ...any) {
	logf(ctx, DebugLevel, format, args)
}

// Debug logs arg, which can be a string or a struct, at the Info level.
func Debug(ctx context.Context, arg any) {
	doLog(ctx, DebugLevel, arg)
}

// Infof logs a formatted string at the Info level.
func Infof(ctx context.Context, format string, args ...any) {
	logf(ctx, InfoLevel, format, args)
}

// Info logs arg, which can be a string or a struct, at the Info level.
func Info(ctx context.Context, arg any) {
	doLog(ctx, InfoLevel, arg)
}

// Fatal logs arg, which can be a string or a struct, at the Info level prefixed with FATAL
// followed by a call to os.Exit(1).
func Fatal(ctx context.Context, arg any) {
	doLog(ctx, InfoLevel, fmt.Sprintf("FATAL: %v", arg))
	os.Exit(1)
}

// Fatalf logs a formated string at the Info level prefixed with FATAL
// followed by a call to os.Exit(1).
func Fatalf(ctx context.Context, format string, args ...any) {
	doLog(ctx, InfoLevel, fmt.Sprintf("FATAL: %v", fmt.Sprintf(format, args...)))
	os.Exit(1)
}

func logf(ctx context.Context, level int, format string, args []any) {
	doLog(ctx, level, fmt.Sprintf(format, args...))
}

func doLog(ctx context.Context, level int, payload any) {
	if getLevel() > level {
		return
	}
	mu.Lock()
	l := state.logger
	mu.Unlock()
	l.log(ctx, level, payload)
}
